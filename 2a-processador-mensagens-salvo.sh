#!/bin/bash

# =================================================================
# SCRIPT 2a: PROCESSADOR DE MENSAGENS WHATSAPP - PROJETO SALV√î
# Parte 2: Processamento de mensagens e envio
# Autor: Claude Assistant
# Data: 2025-09-26
# =================================================================

echo "ü§ñ PROCESSADOR DE MENSAGENS WHATSAPP - PARTE 2a"
echo "==============================================="

# Cores para output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

log_info() { echo -e "${BLUE}[INFO]${NC} $1"; }
log_success() { echo -e "${GREEN}[SUCCESS]${NC} $1"; }
log_warning() { echo -e "${YELLOW}[WARNING]${NC} $1"; }
log_error() { echo -e "${RED}[ERROR]${NC} $1"; }

# Verifica√ß√µes iniciais
log_info "Verificando se Parte 1 foi executada..."

if [ ! -f "app/api/whatsapp/webhook.py" ]; then
    log_error "webhook.py n√£o encontrado! Execute primeiro 2-integracao-whatsapp-salvo.sh"
    exit 1
fi

log_success "Estrutura WhatsApp b√°sica encontrada!"

# =================================================================
# 1. CRIAR PROCESSADOR DE MENSAGENS
# =================================================================

log_info "Criando processador de mensagens..."

cat > app/services/whatsapp/message_processor.py << 'EOF'
"""
Processador de mensagens do WhatsApp - Salv√¥
Identifica inten√ß√µes e processa diferentes tipos de mensagem
"""

import logging
import json
from typing import Dict, List, Optional
from app.services.whatsapp.sender import WhatsAppSender
from app.utils.message_parser import MessageParser

logger = logging.getLogger(__name__)

class MessageProcessor:
    """Processa mensagens recebidas do WhatsApp"""
    
    def __init__(self):
        self.sender = WhatsAppSender()
        self.parser = MessageParser()
    
    def process_messages(self, messages: List[Dict]):
        """Processa lista de mensagens"""
        for message in messages:
            try:
                self.process_single_message(message)
            except Exception as e:
                logger.error(f"‚ùå Erro processando mensagem: {e}")
    
    def process_single_message(self, message: Dict):
        """Processa uma mensagem individual"""
        
        # Extrair dados b√°sicos
        phone = message.get('from', '')
        message_id = message.get('id', '')
        timestamp = message.get('timestamp', '')
        
        logger.info(f"üì® Processando mensagem de {phone}: {message_id}")
        
        # Verificar tipo de mensagem
        message_type = message.get('type', '')
        
        if message_type == 'text':
            self._handle_text_message(phone, message, message_id)
        elif message_type == 'location':
            self._handle_location_message(phone, message, message_id)
        elif message_type == 'interactive':
            self._handle_interactive_message(phone, message, message_id)
        else:
            # Mensagem n√£o suportada
            self.sender.send_text_message(
                phone, 
                "Desculpe, ainda n√£o consigo processar esse tipo de mensagem. "
                "Envie uma mensagem de texto ou sua localiza√ß√£o! üòä"
            )
    
    def _handle_text_message(self, phone: str, message: Dict, message_id: str):
        """Processa mensagens de texto"""
        text_content = message.get('text', {}).get('body', '').lower().strip()
        
        if not text_content:
            return
        
        # Identificar inten√ß√£o
        intent = self.parser.identify_intent(text_content)
        
        logger.info(f"üéØ Inten√ß√£o identificada: {intent} para: {text_content}")
        
        if intent == 'greeting':
            self._send_welcome_message(phone)
        elif intent == 'search':
            self._handle_search_request(phone, text_content)
        elif intent == 'register':
            self._handle_registration_request(phone)
        elif intent == 'help':
            self._send_help_message(phone)
        else:
            # Inten√ß√£o n√£o identificada - assumir busca
            self._handle_search_request(phone, text_content)
    
    def _handle_location_message(self, phone: str, message: Dict, message_id: str):
        """Processa mensagens de localiza√ß√£o"""
        location_data = message.get('location', {})
        latitude = location_data.get('latitude')
        longitude = location_data.get('longitude')
        
        if not latitude or not longitude:
            self.sender.send_text_message(
                phone,
                "üìç N√£o consegui obter sua localiza√ß√£o. Tente enviar novamente!"
            )
            return
        
        logger.info(f"üìç Localiza√ß√£o recebida: {latitude}, {longitude}")
        
        # Por enquanto, enviar mensagem que em breve teremos busca
        self.sender.send_text_message(
            phone,
            f"üìç *Localiza√ß√£o recebida!*\n\n"
            f"Lat: {latitude}\nLng: {longitude}\n\n"
            f"üîÑ Sistema de busca ser√° implementado no pr√≥ximo script!\n\n"
            f"Por enquanto, digite o que voc√™ procura (ex: 'pizza', 'farm√°cia')"
        )
    
    def _handle_interactive_message(self, phone: str, message: Dict, message_id: str):
        """Processa mensagens interativas (bot√µes)"""
        interactive = message.get('interactive', {})
        button_reply = interactive.get('button_reply', {})
        button_id = button_reply.get('id', '')
        
        if button_id == 'new_search':
            self._send_search_instructions(phone)
        elif button_id == 'register_business':
            self._handle_registration_request(phone)
        elif button_id == 'help':
            self._send_help_message(phone)
    
    def _send_welcome_message(self, phone: str):
        """Envia mensagem de boas-vindas"""
        welcome_text = (
            "ü§ñ Ol√°! Eu sou o *Salv√¥*, seu assistente para encontrar com√©rcios locais!\n\n"
            "Como posso te ajudar hoje?\n\n"
            "üìç *Envie sua localiza√ß√£o* para encontrar neg√≥cios pr√≥ximos\n"
            "üí¨ *Digite o que procura* (ex: 'pizzaria', 'farm√°cia')\n"
            "üè™ *Quer cadastrar seu neg√≥cio?* Digite 'cadastrar'"
        )
        
        # Enviar com bot√µes interativos
        self.sender.send_interactive_message(
            phone,
            welcome_text,
            buttons=[
                {"id": "new_search", "title": "üîç Buscar"},
                {"id": "register_business", "title": "üè™ Cadastrar"},
                {"id": "help", "title": "‚ùì Ajuda"}
            ]
        )
    
    def _handle_search_request(self, phone: str, search_term: str):
        """Lida com solicita√ß√µes de busca por texto"""
        self.sender.send_text_message(
            phone,
            f"üîç Entendi que voc√™ est√° procurando por: *{search_term}*\n\n"
            "Para te ajudar melhor, preciso da sua localiza√ß√£o! üìç\n\n"
            "üëÜ Toque no clipe (üìé) > Localiza√ß√£o > Enviar localiza√ß√£o atual\n\n"
            "üîÑ *Sistema de busca real ser√° implementado no pr√≥ximo script!*"
        )
    
    def _handle_registration_request(self, phone: str):
        """Inicia processo de cadastro de neg√≥cio"""
        self.sender.send_text_message(
            phone,
            "üè™ *Cadastro de Neg√≥cio*\n\n"
            "Que legal! Vamos cadastrar seu neg√≥cio no Salv√¥!\n\n"
            "üìù Por enquanto, use nosso formul√°rio online:\n"
            "üëâ https://salvo.vancouvertec.com.br\n\n"
            "Em breve teremos o cadastro 100% pelo WhatsApp! üöÄ"
        )
    
    def _send_help_message(self, phone: str):
        """Envia mensagem de ajuda"""
        help_text = (
            "‚ùì *Como usar o Salv√¥:*\n\n"
            "üîç *Para buscar neg√≥cios:*\n"
            "‚Ä¢ Envie sua localiza√ß√£o üìç\n"
            "‚Ä¢ Ou digite o que procura (ex: 'pizza')\n\n"
            "üè™ *Para cadastrar seu neg√≥cio:*\n"
            "‚Ä¢ Digite 'cadastrar'\n"
            "‚Ä¢ Acesse nosso formul√°rio online\n\n"
            "üí¨ *Precisa de ajuda?*\n"
            "‚Ä¢ Digite 'ajuda' a qualquer momento"
        )
        
        self.sender.send_text_message(phone, help_text)
    
    def _send_search_instructions(self, phone: str):
        """Envia instru√ß√µes para busca"""
        self.sender.send_text_message(
            phone,
            "üîç *Como fazer uma busca:*\n\n"
            "1Ô∏è‚É£ Envie sua localiza√ß√£o atual üìç\n"
            "2Ô∏è‚É£ Ou digite o que voc√™ procura\n\n"
            "üí° *Exemplos:*\n"
            "‚Ä¢ 'pizzaria'\n"
            "‚Ä¢ 'farm√°cia'\n"
            "‚Ä¢ 'mercado'\n"
            "‚Ä¢ 'posto de gasolina'\n\n"
            "Vou buscar os 3 mais pr√≥ximos de voc√™! üéØ"
        )
EOF

# =================================================================
# 2. CRIAR SERVI√áO DE ENVIO WHATSAPP
# =================================================================

log_info "Criando servi√ßo de envio WhatsApp..."

cat > app/services/whatsapp/sender.py << 'EOF'
"""
Servi√ßo para enviar mensagens via WhatsApp Business API - Salv√¥
"""

import requests
import json
import logging
from flask import current_app
from typing import List, Dict, Optional

logger = logging.getLogger(__name__)

class WhatsAppSender:
    """Envia mensagens via WhatsApp Business API"""
    
    def __init__(self):
        self.base_url = "https://graph.facebook.com/v18.0"
        self.phone_number_id = current_app.config.get('WHATSAPP_PHONE_NUMBER_ID')
        self.access_token = current_app.config.get('WHATSAPP_TOKEN')
    
    def send_text_message(self, phone: str, message: str) -> Dict:
        """Envia mensagem de texto simples"""
        
        if not self.phone_number_id or not self.access_token:
            logger.error("‚ùå WhatsApp n√£o configurado - tokens ausentes")
            return {"error": "WhatsApp n√£o configurado"}
        
        url = f"{self.base_url}/{self.phone_number_id}/messages"
        
        headers = {
            "Authorization": f"Bearer {self.access_token}",
            "Content-Type": "application/json"
        }
        
        # Limpar n√∫mero de telefone
        clean_phone = self._clean_phone_number(phone)
        
        payload = {
            "messaging_product": "whatsapp",
            "to": clean_phone,
            "type": "text",
            "text": {
                "body": message
            }
        }
        
        try:
            logger.info(f"üì§ Enviando mensagem para {clean_phone}")
            
            response = requests.post(url, headers=headers, json=payload, timeout=30)
            
            if response.status_code == 200:
                logger.info(f"‚úÖ Mensagem enviada para {clean_phone}")
                return {"success": True, "response": response.json()}
            else:
                logger.error(f"‚ùå Erro ao enviar: {response.status_code} - {response.text}")
                return {"error": f"HTTP {response.status_code}", "details": response.text}
                
        except requests.RequestException as e:
            logger.error(f"‚ùå Erro de conex√£o: {e}")
            return {"error": "Erro de conex√£o", "details": str(e)}
    
    def send_interactive_message(self, phone: str, message: str, buttons: List[Dict]) -> Dict:
        """Envia mensagem com bot√µes interativos"""
        
        if not self.phone_number_id or not self.access_token:
            logger.error("‚ùå WhatsApp n√£o configurado")
            return {"error": "WhatsApp n√£o configurado"}
        
        url = f"{self.base_url}/{self.phone_number_id}/messages"
        
        headers = {
            "Authorization": f"Bearer {self.access_token}",
            "Content-Type": "application/json"
        }
        
        clean_phone = self._clean_phone_number(phone)
        
        # Construir bot√µes (m√°ximo 3 bot√µes)
        button_components = []
        for i, btn in enumerate(buttons[:3]):
            button_components.append({
                "type": "button",
                "button": {
                    "type": "reply",
                    "reply": {
                        "id": btn["id"],
                        "title": btn["title"][:20]  # M√°ximo 20 caracteres
                    }
                }
            })
        
        payload = {
            "messaging_product": "whatsapp",
            "to": clean_phone,
            "type": "interactive",
            "interactive": {
                "type": "button",
                "body": {
                    "text": message
                },
                "action": {
                    "buttons": button_components
                }
            }
        }
        
        try:
            response = requests.post(url, headers=headers, json=payload, timeout=30)
            
            if response.status_code == 200:
                logger.info(f"‚úÖ Mensagem interativa enviada para {clean_phone}")
                return {"success": True, "response": response.json()}
            else:
                logger.error(f"‚ùå Erro mensagem interativa: {response.status_code}")
                return {"error": f"HTTP {response.status_code}", "details": response.text}
                
        except requests.RequestException as e:
            logger.error(f"‚ùå Erro de conex√£o: {e}")
            return {"error": "Erro de conex√£o", "details": str(e)}
    
    def _clean_phone_number(self, phone: str) -> str:
        """Limpa e formata n√∫mero de telefone"""
        # Remover todos os caracteres n√£o num√©ricos
        clean = ''.join(filter(str.isdigit, phone))
        
        # Se come√ßar com 0, remover
        if clean.startswith('0'):
            clean = clean[1:]
        
        # Se n√£o come√ßar com 55 (Brasil), adicionar
        if not clean.startswith('55'):
            clean = '55' + clean
        
        return clean
EOF

# =================================================================
# 3. CRIAR PARSER DE MENSAGENS (IDENTIFICA√á√ÉO DE INTEN√á√ïES)
# =================================================================

log_info "Criando parser de identifica√ß√£o de inten√ß√µes..."

cat > app/utils/message_parser.py << 'EOF'
"""
Parser de mensagens - Identifica inten√ß√µes do usu√°rio - Salv√¥
"""

import re
import logging
from typing import str

logger = logging.getLogger(__name__)

class MessageParser:
    """Identifica inten√ß√µes em mensagens de texto"""
    
    def __init__(self):
        # Padr√µes de sauda√ß√£o
        self.greeting_patterns = [
            r'\b(oi|ol√°|ola|hey|ei|bom dia|boa tarde|boa noite)\b',
            r'\b(tchau|at√© logo|falou|obrigad[ao])\b'
        ]
        
        # Padr√µes de busca
        self.search_patterns = [
            r'\b(procur[oaei]|quero|preciso|busco|onde)\b',
            r'\b(pizza|farmacia|mercado|posto|padaria|restaurante)\b',
            r'\b(comida|remedio|gasolina|p√£o|lanche)\b'
        ]
        
        # Padr√µes de cadastro
        self.register_patterns = [
            r'\b(cadastr[oaei]|registr[oaei]|anunci[oaei])\b',
            r'\b(meu negocio|minha empresa|minha loja)\b',
            r'\b(divulgar|promover|vender)\b'
        ]
        
        # Padr√µes de ajuda
        self.help_patterns = [
            r'\b(ajuda|help|como|tutorial|duvida)\b',
            r'\b(n√£o entendi|n√£o sei|me explica)\b'
        ]
    
    def identify_intent(self, text: str) -> str:
        """
        Identifica a inten√ß√£o principal do texto
        
        Returns:
            'greeting', 'search', 'register', 'help', ou 'unknown'
        """
        
        if not text or not text.strip():
            return 'unknown'
        
        text_lower = text.lower().strip()
        
        # Verificar sauda√ß√µes primeiro
        if self._matches_patterns(text_lower, self.greeting_patterns):
            logger.debug("ü§ù Inten√ß√£o: sauda√ß√£o")
            return 'greeting'
        
        # Verificar cadastro
        if self._matches_patterns(text_lower, self.register_patterns):
            logger.debug("üè™ Inten√ß√£o: cadastro")
            return 'register'
        
        # Verificar ajuda
        if self._matches_patterns(text_lower, self.help_patterns):
            logger.debug("‚ùì Inten√ß√£o: ajuda")
            return 'help'
        
        # Verificar busca
        if self._matches_patterns(text_lower, self.search_patterns):
            logger.debug("üîç Inten√ß√£o: busca")
            return 'search'
        
        # Se n√£o identificou, assumir que √© busca (comportamento padr√£o)
        logger.debug("üîç Inten√ß√£o: busca (padr√£o)")
        return 'search'
    
    def _matches_patterns(self, text: str, patterns: list) -> bool:
        """Verifica se texto corresponde a algum padr√£o da lista"""
        for pattern in patterns:
            if re.search(pattern, text, re.IGNORECASE):
                return True
        return False
    
    def extract_search_terms(self, text: str) -> list:
        """Extrai termos de busca do texto"""
        # Palavras comuns a ignorar
        stop_words = [
            'o', 'a', 'os', 'as', 'um', 'uma', 'de', 'do', 'da', 'dos', 'das',
            'em', 'no', 'na', 'nos', 'nas', 'para', 'por', 'com', 'sem',
            'que', 'qual', 'quais', 'onde', 'como', 'quando', 'porque',
            'eu', 'voc√™', 'ele', 'ela', 'n√≥s', 'voc√™s', 'eles', 'elas',
            'meu', 'minha', 'seu', 'sua', 'nosso', 'nossa',
            'procuro', 'quero', 'preciso', 'busco', 'procurar', 'encontrar'
        ]
        
        # Limpar e dividir texto
        words = re.findall(r'\b\w+\b', text.lower())
        
        # Filtrar palavras relevantes
        search_terms = [
            word for word in words 
            if len(word) > 2 and word not in stop_words
        ]
        
        return search_terms[:5]  # M√°ximo 5 termos
EOF

# =================================================================
# 4. CRIAR ARQUIVOS __INIT__.PY NECESS√ÅRIOS
# =================================================================

log_info "Criando arquivos __init__.py..."

cat > app/services/whatsapp/__init__.py << 'EOF'
"""
Servi√ßos WhatsApp do Salv√¥
"""
from .message_processor import MessageProcessor
from .sender import WhatsAppSender

__all__ = ['MessageProcessor', 'WhatsAppSender']
EOF

cat > app/utils/__init__.py << 'EOF'
"""
Utilit√°rios do Salv√¥
"""
from .message_parser import MessageParser

__all__ = ['MessageParser']
EOF

# =================================================================
# FINALIZA√á√ÉO PARTE 2a
# =================================================================

log_success "Processador de mensagens criado!"

echo ""
echo "‚úÖ PARTE 2a CONCLU√çDA COM SUCESSO!"
echo "=================================="
echo ""
echo "ü§ñ O que foi implementado:"
echo "   ‚úÖ MessageProcessor - processa mensagens recebidas"
echo "   ‚úÖ WhatsAppSender - envia mensagens e bot√µes" 
echo "   ‚úÖ MessageParser - identifica inten√ß√µes do usu√°rio"
echo "   ‚úÖ Suporte a texto, localiza√ß√£o e bot√µes interativos"
echo ""
echo "üéØ Funcionalidades ativas:"
echo "   üì® Recebimento de mensagens"
echo "   ü§ù Sauda√ß√µes e boas-vindas"
echo "   üîç Identifica√ß√£o de inten√ß√µes de busca"
echo "   üè™ Solicita√ß√µes de cadastro"
echo "   ‚ùì Sistema de ajuda"
echo "   üìç Recebimento de localiza√ß√£o"
echo ""
echo "üß™ Para testar agora:"
echo "   1. Configure tokens no .env"
echo "   2. python app/main.py"
echo "   3. POST /api/whatsapp/test"
echo "   4. Configure webhook no Facebook"
echo ""
echo "üöÄ Pr√≥ximo passo:"
echo "   ./2b-sistema-busca-salvo.sh"
echo "   (Sistema de busca por geolocaliza√ß√£o)"
echo ""